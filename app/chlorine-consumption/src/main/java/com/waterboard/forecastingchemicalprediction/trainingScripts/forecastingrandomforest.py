# -*- coding: utf-8 -*-
"""Forecastingrandomforest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13OwxhOHS9jLG0391LPgVk8vchkU1CJRz
"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.multioutput import MultiOutputRegressor
from sklearn.metrics import mean_squared_error
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

# Load the dataset
df = pd.read_excel('/content/weather_based_water_quality_data.xlsx')

# Select relevant columns for training
# For Step 1: Predicting Initial Chlorine, pH, Turbidity based on Water Volume, Rain Probability, Temperature
X = df[['Water Volume (Cubic Meters)', 'Rain Probability (%)', 'Temperature (°C)']]
y = df[['Initial Chlorine (ppm)', 'Initial pH', 'Initial Turbidity']]

# Split the dataset into training and testing sets (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Normalize the data (optional, but can help certain models like neural networks)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Initialize the RandomForestRegressor model for predicting Initial Chlorine, pH, Turbidity
rf_model_initial = MultiOutputRegressor(RandomForestRegressor(n_estimators=100, random_state=42))

# Train the model
rf_model_initial.fit(X_train, y_train)

# Make predictions on the test set
rf_predictions_initial = rf_model_initial.predict(X_test)

# Evaluate the model
rf_mse_initial = mean_squared_error(y_test, rf_predictions_initial)
print("Random Forest Mean Squared Error for Initial Chlorine, pH, Turbidity:", rf_mse_initial)

# Example Prediction: Now, the user will enter only Water Volume, Rain Probability, and Temperature
user_input = pd.DataFrame({
    'Water Volume (Cubic Meters)': [24299],
    'Rain Probability (%)': [13.4],  # Example rain probability
    'Temperature (°C)': [37.4]      # Example temperature
})

# Scale the user input data
user_input_scaled = scaler.transform(user_input)

# Predict Initial Chlorine, pH, Turbidity
rf_pred_initial = rf_model_initial.predict(user_input_scaled)
print("Predicted Initial Chlorine (ppm):", rf_pred_initial[0][0])
print("Predicted Initial pH:", rf_pred_initial[0][1])
print("Predicted Initial Turbidity:", rf_pred_initial[0][2])

# Step 2: Use predicted Initial Chlorine, pH, Turbidity to predict Applied Chlorine, Calcium Carbonate, PAC

# Now, create a new model for predicting Applied Chlorine, Calcium Carbonate, and PAC
# You will need to modify the dataset to include these values for training
X_full = df[['Water Volume (Cubic Meters)', 'Rain Probability (%)', 'Temperature (°C)', 'Initial Chlorine (ppm)', 'Initial pH', 'Initial Turbidity']]
y_full = df[['Applied Chlorine (KG)', 'Applied Calcium Carbonate (KG)', 'Applied PAC (KG)']]

# Split the dataset into training and testing sets (80% train, 20% test) for this new model
X_train_full, X_test_full, y_train_full, y_test_full = train_test_split(X_full, y_full, test_size=0.2, random_state=42)

# Normalize the data (optional, but can help certain models like neural networks)
X_train_full = scaler.fit_transform(X_train_full)
X_test_full = scaler.transform(X_test_full)

# Initialize the RandomForestRegressor model for predicting Applied Chlorine, Calcium Carbonate, and PAC
rf_model_full = MultiOutputRegressor(RandomForestRegressor(n_estimators=100, random_state=42))

# Train the model
rf_model_full.fit(X_train_full, y_train_full)

# Make predictions
rf_predictions_full = rf_model_full.predict(X_test_full)

# Evaluate the model
rf_mse_full = mean_squared_error(y_test_full, rf_predictions_full)
print("Random Forest Mean Squared Error for Applied Chlorine, Calcium Carbonate, PAC:", rf_mse_full)

# Example Prediction for Applied Chlorine, Calcium Carbonate, PAC using predicted Initial Chlorine, pH, Turbidity
user_input_full = pd.DataFrame({
    'Water Volume (Cubic Meters)': [24299],
    'Rain Probability (%)': [13.4],  # Example rain probability
    'Temperature (°C)': [37.4],     # Example temperature
    'Initial Chlorine (ppm)': [rf_pred_initial[0][0]],  # Predicted value
    'Initial pH': [rf_pred_initial[0][1]],              # Predicted value
    'Initial Turbidity': [rf_pred_initial[0][2]]        # Predicted value
})

# Scale the user input data
user_input_scaled_full = scaler.transform(user_input_full)

# Predict Applied Chlorine, Calcium Carbonate, PAC
rf_pred_full = rf_model_full.predict(user_input_scaled_full)
print("Predicted Applied Chlorine (KG):", rf_pred_full[0][0])
print("Predicted Applied Calcium Carbonate (KG):", rf_pred_full[0][1])
print("Predicted Applied PAC (KG):", rf_pred_full[0][2])

from joblib import dump  # For saving models

# Save the first model (Initial Chlorine, pH, Turbidity)
dump(rf_model_initial, 'rf_model_initial.bin')

# Save the second model (Applied Chlorine, Calcium Carbonate, PAC)
dump(rf_model_full, 'rf_model_full.bin')

pip install onnxmltools onnx

pip install onnxconverter-common

pip install onnx

pip install skl2onnx onnxconverter-common

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.multioutput import MultiOutputRegressor
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error, r2_score
from onnxmltools.convert.common.data_types import FloatTensorType
import onnxmltools  # For ONNX conversion

# Load dataset
file_path = '/content/weather_based_water_quality_data.xlsx'
data = pd.read_excel(file_path)

# Drop unused columns
data = data.drop(columns=['Season Category'])  # Ignoring the 'Season Category' column

# Features (X) and targets (y)
X = data[['Water Volume (Cubic Meters)', 'Rain Probability (%)', 'Temperature (°C)']]
y = data[['Applied Chlorine (KG)', 'Applied Calcium Carbonate (KG)', 'Applied PAC (KG)']]

# Rename feature columns to numeric indices for compatibility
X.columns = [f'f{i}' for i in range(X.shape[1])]

# Split into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Define the model
xgb_regressor = XGBRegressor(objective='reg:squarederror', n_estimators=100, learning_rate=0.1, max_depth=5)

# Multi-output regressor to handle multiple target variables
multi_output_model = MultiOutputRegressor(xgb_regressor)

# Train the model
multi_output_model.fit(X_train, y_train)

# Predict on test set
y_pred = multi_output_model.predict(X_test)

# Evaluate the model
rmse = np.sqrt(mean_squared_error(y_test, y_pred, multioutput='raw_values'))
r2 = r2_score(y_test, y_pred, multioutput='uniform_average')

print("RMSE (per target):", rmse)
print("R2 Score:", r2)

# Save the model to ONNX format
initial_type = [('input', FloatTensorType([None, X_train.shape[1]]))]

# Convert the multi-output model (each estimator individually)
for i, estimator in enumerate(multi_output_model.estimators_):  # Access individual regressors
    onnx_model = onnxmltools.convert_xgboost(estimator, initial_types=initial_type)

    # Save each ONNX model to a separate file
    onnx_filename = f"multi_output_model_target_{i}.onnx"
    with open(onnx_filename, "wb") as f:
        f.write(onnx_model.SerializeToString())
    print(f"Saved ONNX model for target {i} to {onnx_filename}")

# Example prediction
example_input = np.array([[24299, 13.4, 37.4]])  # Replace with user inputs: water volume, rain probability, temperature
example_prediction = multi_output_model.predict(example_input)
print("Predicted (Applied Chlorine, Calcium Carbonate, PAC):", example_prediction)